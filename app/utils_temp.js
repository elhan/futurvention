/*global Constants, document, Emoticons, escape, logger, navigator, sdpParser, unescape,
window, XMLHttpRequest*/
/*exported Utils*/

// Define the object
var Utils = {};

Utils.directiveCleaner = function (element, remove, scope, name) {
    'use strict';
    try {
        if (!element) {
            return;
        }
        name && logger.debug('[Utils]: directiveCleaner - directive =', name);

        element.off();
        element.unbind();
        var dat = element.data();
        if (dat) {
            if (dat.hasOwnProperty('popover')) {
                element.data().popover.destroy();
            }
            if (dat.hasOwnProperty('blueimpFileupload')) {
                dat.blueimpFileupload.destroy();
            }
        }
        if (scope) {
            if (element.children() && element.children().length < 1) {
                if (dat && dat.hasOwnProperty('$isolateScopeNoTemplate')) {
                    dat.$isolateScopeNoTemplate.$destroy();
                }
            }
            if (remove) {
                element.empty();
                element.remove();
            }
        }
    } catch (e) {
        logger.error('[Utils]: Error on directiveCleaner -', e);
    }
};

Utils.json2xml = function (obj, tag) {
    'use strict';
    if (obj === undefined || obj === null) {
        return tag ? ('<' + tag + '/>') : '';
    }

    var xml = '';

    function addElement(value) {
        if (tag) {
            xml += '<' + tag + '>' + value + '</' + tag + '>';
        } else {
            xml += value;
        }
    }

    switch (typeof(obj)) {
    case 'string':
        addElement($('<div>').text(obj).html());
        break;
    case 'object':
        if (obj instanceof Date) {
            addElement(obj.toISOString());
        } else if (obj instanceof Array) {
            if (tag) {
                xml += '<' + tag + '>';
            }
            obj.forEach(function (o) {
                xml += Utils.json2xml(o, 'item');
            });
            if (tag) {
                xml += '</' + tag + '>';
            }
        } else {
            if (tag) {
                xml += '<' + tag + '>';
            }
            for (var attr in obj) {
                if (obj.hasOwnProperty(attr) && (typeof obj[attr] !== 'function')) {
                    xml += Utils.json2xml(obj[attr], attr);
                }
            }
            if (tag) {
                xml += '</' + tag + '>';
            }
        }
        break;
    default:
        addElement(obj);
        break;
    }
    return xml;
};

Utils.encodeUTF8 = function (s) {
    'use strict';
    return unescape(encodeURIComponent(s));
};

/**
 * Removes restrictions from the encodeURIComponent() function
 */
Utils.enhanceEncodeURI = function (s) {
    'use strict';

    // mappings to replace '!,(,)' with proper encoding
    var charactersMap = {
        '!': '%21',
        '(': '%28',
        ')': '%29'
    };

    return encodeURIComponent(s).replace(/[!\(\)]/gi, function (matched) {
        return charactersMap[matched];
    });
};

Utils.decodeUTF8 = function (s) {
    'use strict';
    return decodeURIComponent(escape(s));
};

Utils.urlExists = function (url) {
    'use strict';
    var http = new XMLHttpRequest();
    http.open('HEAD', url, false);
    http.send();
    return (http.status !== 404);
};

Utils.normalizeDn = function (dn) {
    'use strict';
    if (!dn) {
        return '';
    }
    return dn.replace('+', '');
};

/**
 * Checks the meta tags for a given Html input to determine if the html data source is a MS document.
 * Used when pasting in the conversation input.
 */
Utils.isMSDoc = function (content) {
    'use strict';
    // check if the content html string was generated by MSO
    var isMSDoc = false;
    var metaTagArray = content.match(/<\s*\/?\s*meta\s*.*?>/g);
    metaTagArray && metaTagArray.forEach(function (meta) {
        if (meta.toLowerCase().indexOf('microsoft') !== -1) {
            isMSDoc = true;
        }
    });
    return isMSDoc;
};

/**
 * Text pasted with existing formatting is reduced down to a subset of the Ansible supported formatting options:
 * all HTML tags that are not for bold, italic, bullets, linebreaks, paragraphs or headers are removed
 * or replaced according to specific rules. Then, all attributes from the remaining tags are also removed.
 */
Utils.formatHtml = function (content) {
    'use strict';
    var replacementRules = [
        [/<\s*p.*?>/ig, '<br>'], // replace <p> tags and their attributes with <br>
        [/<\s*em.*?>/ig, '<i>'], // replace <em> tags and their attributes with <i>
        [/<\s*\/\s*em\s*.*?>/ig, '</i>'], // replace </em> tags and their attributes with </i>
        [/<\s*strong.*?>/ig, '<b>'], // replace <strong> tags with <b>
        [/<\s*h[0-9]{1}.*?>/ig, '<br><b>'], // replace header tags with <b> and </br>
        [/<\s*\/\s*strong\s*.*?>/ig, '</b>'],// replace </strong> with </b>
        [/<\s*\/\s*h[0-9]{1}\s*.*?>/ig, '</b></br>'] // replace  header closing tags with </b></br>
    ];

    // replace tags according to the rules
    return Emoticons.normalizeEmoticonHtml(content.replace(/<(?!\s*\/?(b|i|ul|ol|li|br|img)\b)[^>]+>/ig, function (token) {
        var replacement = '';
        var tokenStr = token.toString();
        replacementRules.some(function (rule) {
            replacement = (tokenStr.match(rule[0]) !== null) ? rule[1] : '';
            return replacement === rule[1]; // break loop if rule was matched
        });
        return replacement;
    })
    // remove attributes except for image tags
    .replace(/<(?!\s*\/?(img)\b)[^>]+>/ig, function (token) {
        return token.replace(/\s*\w+="[^"]*"/ig, '');
    }));
};

Utils.toPlainText = function (content, type, custom) {
    'use strict';

    function processCustomContent(content) {
        if (content) {
            return content.replace(/<img[^>|<]*shortcut="(\S*)"[^\/?>]*\/?>/gi, '$1'); // Any img tag found is emoticon one, all other user input html is escaped
        }                                                                         // replace them with their shortcut
        return content;
    }

    if (content) {
        if (!type || (type === Constants.TextItemContentType.RICH)) { // If type parameter is omitted or is 'RICH', convert to plain
            if (custom) {
                content = processCustomContent(content);
            }
            var elem = document.createElement('div');
            elem.innerHTML = content.replace(/<(br|\/li)>/gi, '&nbsp;');
            return elem.textContent;
        }
    }
    return content; // In any other case (type parameter set but not 'RICH' - e.g. 'PLAIN'), don't convert
};

Utils.toPlainTextWithEmoticonHtml = function (content, type, custom) {
    'use strict';

    var LT = String.fromCharCode(17); // Temporary mapping using non-printable ascii code x11 (DEC 17)
    var GT = String.fromCharCode(18); // Temporary mapping using non-printable ascii code x12 (DEC 18)

    function processCustomContent(content) {
        if (content) {
            return content.replace(/<img[^>|<]*shortcut="(\S*)"[^\/?>]*\/?>/gi, LT + '$1' + GT); // Any img tag found is emoticon one, all other user input html is escaped
        }                                                                                   // replace them with their shortcut + some non-printable characters, so we can restore them
        return content;
    }

    if (content) {
        if (!type || (type === Constants.TextItemContentType.RICH)) { // If type parameter is omitted or is 'RICH', convert to plain
            if (custom) {
                content = processCustomContent(content);
            }
            var elem = document.createElement('div');
            elem.innerHTML = content.replace(/<(br|\/li)>/gi, '&nbsp;');
            var textContent = Utils.textToHtmlEscaped(elem.textContent, true); // Escape any user input html code typed e.g. '<'

            // Restore emoticon html replacing all shortcuts found inside LT and GT non-printable characters (x11, x12) with their html code equivalent
            // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter
            return textContent.replace(/\x11([^\x11\x12]*)\x12/gim, function (match, contents/*, offset, s*/) {
                return Emoticons.getHtmlFromShortcut(contents);
            });
        }
    }
    return content; // In any other case (type parameter set but not 'RICH' - e.g. 'PLAIN'), don't convert
};

// Truncates big file names and puts ellipsis in the middle
Utils.truncateFileName = function (fileName) {
    'use strict';
    if (!fileName || fileName.length <= 22) {
        return fileName;
    }
    return fileName.substring(0, 10) + ' ...' +
        fileName.substring(fileName.length - 8, fileName.length);
};

Utils.convertItemText = function (content, type, custom, keepEmoticonHtml) {
    'use strict';
    if (!content) {
        return '';
    }
    if (keepEmoticonHtml) {
        return Utils.toPlainTextWithEmoticonHtml(content, type, custom);
    }
    return Utils.toPlainText(content, type, custom);
};

Utils.invertHash = function (originalHash) { // Inverts keys-values for a given hash
    'use strict';

    var newHash = {};
    if (originalHash) {
        for (var key in originalHash) {
            if (key) {
                var value = originalHash[key];
                if (value) {
                    newHash[value] = key;
                }
            }
        }
    }
    return newHash;
};

Utils.localizeSystemNotification = function (feed, i18n, localize, toPlainText, creatorTenantId) {
    'use strict';

    if (!feed.system || !feed.i18nResourceName) {
        return '';
    }
    var guestStr = ' (' + i18n.map.res_Guest + ')';

    var showGuest = feed.creator.isGuest || creatorTenantId !== feed.creator.tenantId;
    var creator = feed.creator.displayName + (showGuest ? guestStr : '');

    var users = '';
    if (feed.otherAffectedUsers) {
        users = feed.otherAffectedUsers.map(function (p) {

            showGuest = p.isGuest || creatorTenantId !== p.tenantId;
            return p.displayName + (showGuest ? guestStr : '');
        });
        var last = '';
        if (users.length > 1 || (users.length === 1 && feed.isLocalUserAffected)) {
            last = ' ' + i18n.map.res_and + ' ';
            if (!feed.isLocalUserAffected) {
                last = last + users.pop();
            }
        }
        users = users.join(', ') + last;
    }

    var additionalData = feed.i18nResourceParam &&
        feed.i18nResourceParam.replace('__and__', i18n.map.res_and);

    // Set the parameters
    var params = [creator, users, additionalData];

    // Now create the localized string
    var res = localize(feed.i18nResourceName, params);
    return toPlainText ? Utils.toPlainText(res) : res;
};

// http, https, ftp url pattern
Utils.URL_PATTERN = /(http|ftp|https):\/\/[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:\/~+#!\(\)-]*[\w@?^=%&amp;\/~+#-])?/gim;

// www. sans http:// or https://
Utils.PSEUDO_URL_PATTERN = /(^|[^\/])(www\.[\S]+(\b|$))/gim;

// Email addresses
Utils.EMAIL_ADDRESS_PATTERN = /^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$/im;

// Phone numbers. Examples:
//   15615551234
//   1.561.555.1234
//   +15615551234
//   +1-561-555-1234
//   +1(561)555-1234
Utils.PHONE_PATTERN = /^(\+\s*)?\d+(\s*\(\s*\d+\s*\)\s*\d+)?((\s+\d+)*|(\s*-\s*\d+)*|(\s*\.\s*\d+)*)$/;

Utils.GNF_PHONE_PATTERN = /^\+\s*\d+(\s*\(\s*\d+\s*\)\s*\d+)?((\s+\d+)*|(\s*-\s*\d+)*|(\s*\.\s*\d+)*)$/;

Utils.LOG_FILE_NAME_PATTERN = /^wcans.{0,4}\d{14}\.log$/;

Utils.matchPhonePattern = function (str) {
    'use strict';
    if (!str || typeof(str) !== 'string') {
        return null;
    }
    return str.match(Utils.PHONE_PATTERN);
};

Utils.matchGNFPhonePattern = function (str) {
    'use strict';
    if (!str || typeof(str) !== 'string') {
        return null;
    }
    return str.match(Utils.GNF_PHONE_PATTERN);
};

Utils.matchUrlPattern = function (str) {
    'use strict';
    if (!str || typeof(str) !== 'string') {
        return null;
    }
    return str.match(Utils.URL_PATTERN) || str.match(Utils.PSEUDO_URL_PATTERN);
};

Utils.matchEmailPattern = function (str) {
    'use strict';
    if (!str || typeof(str) !== 'string') {
        return null;
    }
    return str.match(Utils.EMAIL_ADDRESS_PATTERN);
};

Utils.matchNames = function (str, query, flag) {
    'use strict';
    if (typeof(str) !== 'string' || !query) {
        return false;
    }
    var reName = new RegExp('^' + RegExp.escape(query), flag || 'i');
    return reName.test(str) || str.split(' ').some(function (name) {
        return reName.test(name);
    });
};

Utils.hasAnsibleLogFilePattern = function (str) {
    'use strict';
    if (!str || typeof(str) !== 'string') {
        return false;
    }
    if (str.startsWith('wcans') && str.endsWith('.log')) {
        return Utils.LOG_FILE_NAME_PATTERN.test(str);
    }
    return false;
};

Utils.rstring = function () {
    'use strict';
    return Math.floor(Math.random() * 1e9).toString();
};

Utils.randomNumber = function (min, max) {
    'use strict';
    return Math.floor(Math.random() * (max - min + 1)) + min;
};

Utils.randomBoolean = function () {
    'use strict';
    return 0.5 > Math.random();
};

Utils.randomValueOfObject = function (obj) {
    'use strict';
    var a = [];
    var k;

    for (k in obj) {
        if (obj.hasOwnProperty(k)) {
            a.push(k);
        }
    }

    if (a.length === 0) {
        return null;
    }

    return obj[a[Math.floor(Math.random() * a.length)]];
};

Utils.generateCallId = function () {
    'use strict';
    return 'WRTC-' + Utils.rstring() + '-' + Utils.rstring();
};

Utils.getBrowserInfo = function () {
    'use strict';
    var browserData = {};
    var ua = navigator.userAgent.match(/(opera|chrome|safari|firefox|iPhone|iPad|Android|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
    var ver = navigator.userAgent.match(/version\/([\.\d]+)/i);

    if (ua && ver) {
        ua[2] = ver[1];
    }

    if (ua) {
        browserData.type = ua[1];      // browser type: e.g "chrome"
        browserData.version = ua[2];   // browser version: e.g "27.0.1453.110"
    } else {
        browserData.type = navigator.appName;
        browserData.version = navigator.appVersion;
    }
    return browserData;
};

Utils.formatStats = function (stats, pc) {
    'use strict';

    if (!stats || !pc) {
        return null;
    }

    var elapsedSecondsPeerConnection = Math.floor((Date.now() - pc.startTime) / 1000);
    if (elapsedSecondsPeerConnection < 0) {
        elapsedSecondsPeerConnection = 0;
    }

    var formattedStats = {};
    var results = stats.result();
    if (!results) {
        return null;
    }

    results.forEach(function (res) {
        var mediaptr = null;
        if (res.type === 'ssrc') {
            // Chrome v27.0.1453: transportId:Channel-audio-1 and transportId:Channel-video-1 were not available yet. Instead other fields were checked
            // ...to find out if it is video or audio stats
            if (res.stat('audioInputLevel') || res.stat('audioOutputLevel')) {
                if (!formattedStats.audio) {
                    formattedStats.audio = {
                            mt: 0, // MT(0=audio,1=video,2=text,3=application,4=message)
                            du: elapsedSecondsPeerConnection
                        };
                }
                mediaptr = formattedStats.audio;
            } else if (res.stat('googFrameHeightSent') || res.stat('googFrameHeightReceived')) {
                if (!formattedStats.video) {
                    formattedStats.video = {
                            mt: 1,     // MT(0=audio,1=video,2=text,3=application,4=message)
                            st: 'VP8', // hardcoded by now since it is the only video codec
                            du: elapsedSecondsPeerConnection
                        };
                }
                mediaptr = formattedStats.video;
            }
        }

        if (res.names && mediaptr) {
            var resNames = res.names() || [];
            resNames.forEach(function (name) {
                switch (name) {
                case 'bytesReceived':
                    mediaptr.or = res.stat(name);
                    break;
                case 'bytesSent':
                    mediaptr.os = res.stat(name);
                    break;
                case 'packetsLost':
                    mediaptr.pl = res.stat(name);
                    break;
                case 'packetsReceived':
                    mediaptr.pr = res.stat(name);
                    break;
                case 'packetsSent':
                    mediaptr.ps = res.stat(name);
                    break;
                default:
                    break;
                }
            });
        }
    });
    var parsedSdp;
    if (pc.localDescription && pc.localDescription.sdp) {
        parsedSdp = sdpParser.parse(pc.localDescription.sdp);
        parsedSdp.m.forEach(function (m) {
            if (formattedStats[m.media]) {
                formattedStats[m.media].ptl = m.port;
                formattedStats[m.media].ipl = (m.c && m.c.address) || (parsedSdp.c && parsedSdp.c.address);
            }
        });
    }
    if (pc.remoteDescription && pc.remoteDescription.sdp) {
        parsedSdp =  sdpParser.parse(pc.remoteDescription.sdp);
        parsedSdp.m.forEach(function (m) {
            if (formattedStats[m.media]) {
                formattedStats[m.media].ptr = m.port;
                formattedStats[m.media].ipr = (m.c && m.c.address) || (parsedSdp.c && parsedSdp.c.address);
            }
        });
    }
    if (formattedStats.audio) {
        var browserData = Utils.getBrowserInfo();
        formattedStats.audio.ud = 'WebRTC';
        formattedStats.audio.udt = browserData.type;
    }
    return formattedStats;
};


Utils.getRTPStats = function (pc, cb) {
    'use strict';
    if (pc && pc.getStats) {
        pc.getStats(function (stats) {
            cb && cb(null, Utils.formatStats(stats, pc));
        },
        cb);
    } else {
        cb && cb('getStats or pc not available');
    }
};

Utils.formatStatsForClientDiagnostics = function (stats, pc) {
    'use strict';

    if (!stats || !pc) {
        return null;
    }

    var formattedStats = {};
    var results = stats.result();
    if (!results) {
        return null;
    }

    results.forEach(function (res) {
        var statsPtr = null;
        if ((res.type === 'googCandidatePair') && (res.stat('googActiveConnection') === 'true')) {
            if (res.stat('googChannelId') === 'Channel-audio-1') {
                formattedStats.audioRtt = parseInt(res.stat('googRtt'), 10);
            } else {
                formattedStats.videoRtt = parseInt(res.stat('googRtt'), 10);
            }
        } else if (res.type === 'ssrc') {
            // Chrome Canary 35.0.1905.2: transportId:Channel-audio-1 and transportId:Channel-video-1 were not available yet. Instead other fields were checked
            // ...to find out if it is video or audio stats
            if (res.stat('audioInputLevel')) {
                if (!formattedStats.audioTransmit) {
                    formattedStats.audioTransmit = {
                            id: res.id
                        };
                }
                statsPtr = formattedStats.audioTransmit;
            }
            if (res.stat('audioOutputLevel')) {
                if (!formattedStats.audioReceive) {
                    formattedStats.audioReceive = {
                            id: res.id
                        };
                }
                statsPtr = formattedStats.audioReceive;
            }
            if (res.stat('googFrameHeightSent')) {
                if (!formattedStats.videoTransmit) {
                    formattedStats.videoTransmit = {
                            id: res.id
                        };
                }
                statsPtr = formattedStats.videoTransmit;
            }
            if (res.stat('googFrameHeightReceived')) {
                if (!formattedStats.videoReceive) {
                    formattedStats.videoReceive = {
                            id: res.id
                        };
                }
                statsPtr = formattedStats.videoReceive;
            }
        }
        var statsHash = {
            /*
            'bytesReceived':                             'or',
            'bytesSent':                                 'os',
            'googAvgEncodeMs':                           'ae',
            'googBandwidthLimitedResolution':            'blr',
            */
            'googCaptureJitterMs':                       'cj',
            /*
            'googCaptureQueueDelayMsPerS':               'cqd',
            'googCpuLimitedResolution':                  'clr',
            'googCurrentDelayMs':                        'cdm',
            'googDecodeMs':                              'dm',
            'googEchoCancellationEchoDelayMedian':       'ecedm',
            'googEchoCancellationEchoDelayStdDev':       'ecedsd',
            'googEchoCancellationQualityMin':            'ecqm',
            'googEchoCancellationReturnLoss':            'ecrl',
            'googEchoCancellationReturnLossEnhancement': 'ecrle',
            'googEncodeUsagePercent':                    'eup',
            'googExpandRate':                            'ert',
            'googFirsReceived':                          'fr',
            'googFirsSent':                              'fs',
            'googFrameRateDecoded':                      'frd',
            'googFrameRateInput':                        'fri',
            'googFrameRateOutput':                       'fro',
            'googFrameRateReceived':                     'frr',
            'googFrameRateSent':                         'frs',
            'googJitterBufferMs':                        'jb',
            */
            'googJitterReceived':                        'jr',
            /*
            'googMaxDecodeMs':                           'mdm',
            'googMinPlayoutDelayMs':                     'mpd',
            'googNacksReceived':                         'nr',
            'googNacksSent':                             'ns',
            'googPlisReceived':                          'plr',
            'googPlisSent':                              'pls',
            'googPreferredJitterBufferMs':               'pjb',
            'googRenderDelayMs':                         'rd',
            */
            'googRtt':                                   'rtt',
            /*
            'googTargetDelayMs':                         'td',
            'googViewLimitedResolution':                 'vlr',
            */
            'packetsLost':                               'pl',
            'packetsReceived':                           'pr',
            'packetsSent':                               'ps'
        };
        if (res.names && statsPtr) {
            var resNames = res.names() || [];
            resNames.forEach(function (name) {
                if (statsHash[name]) {
                    statsPtr[statsHash[name]] = parseInt(res.stat(name), 10);
                }
            });
        }
    });

    return formattedStats;
};

Utils.getRTPStatsForClientDiagnostics = function (pc, cb) {
    'use strict';
    if (pc && pc.getStats) {
        pc.getStats(function (stats) {
            cb && cb(null, Utils.formatStatsForClientDiagnostics(stats, pc));
        },
        cb);
    } else {
        cb && cb('getStats or pc not available');
    }
};

Utils.isEmptyObject = function (obj) {
    'use strict';
    return Object.keys(obj).length === 0;
};

// Get the prototypical base object (__proto__) and optionally update the base
// object with properties set on the object itself.
// Note: Only first-level properties are updated, no recursion.
Utils.getBaseObject = function (obj, updateBaseObj) {
    'use strict';

    if (!obj || (typeof obj !== 'object')) {
        return null;
    }

    if (obj instanceof Array) {
        return obj;
    }

    var base = Object.getPrototypeOf(obj);

    if (Utils.isEmptyObject(base)) {
        // obj was constructed directly from Object
        return obj;
    }

    if (updateBaseObj !== false) {
        Object.getOwnPropertyNames(base).forEach(function (name) {
            if (typeof base[name] !== 'function' && obj.hasOwnProperty(name)) {
                base[name] = obj[name];
            }
        });
    }
    return base;
};

// Get the prototypical base object (__proto__), updates the base object with
// properties set on the object itself, and finally deletes those properties
// from the object itself.
// Note: Only first-level properties are updated, no recursion.
Utils.syncBaseObject = function (obj) {
    'use strict';
    var base = Utils.getBaseObject(obj, true);
    if (!base || base === obj) {
        return;
    }
    Object.getOwnPropertyNames(base).forEach(function (name) {
        if (obj.hasOwnProperty(name)) {
            delete obj[name];
        }
    });
};


// Flattens prototyped objects, so JSON.stringify will also include the prototype's properties.
Utils.flattenObj = function (obj) {
    'use strict';
    if (!obj || (typeof obj !== 'object')) {
        return obj;
    }

    var base = Object.getPrototypeOf(obj);
    if (Utils.isEmptyObject(base)) {
        // obj was constructed directly from Object
        return obj;
    }

    var tmp = {};
    for (var key in obj) {
        if (typeof obj[key] !== 'function') {
            tmp[key] = obj[key];
        }
    }
    return tmp;
};

Utils.getNormalizedFileExtension = function (file) {
    'use strict';
    var fileName = file && (file.fileName || file.name);
    if (!fileName) {
        return null;
    }

    if ((/audio/i).test(file.mimeType)) {
        return 'mp3';
    }

    if ((/video/i).test(file.mimeType)) {
        return 'video';
    }

    var fileExt = fileName.split('.').pop();
    if (fileExt) {
        switch (fileExt.toLowerCase()) {
        case 'doc':
        case 'docx':
            return 'doc';
        case 'ppt':
        case 'pptx':
            return 'ppt';
        case 'pdf':
            return 'pdf';
        case 'xls':
        case 'xlsx':
            return 'xls';
        case 'gz':
        case 'zip':
            return 'zip';
        case 'html':
            return 'html';
        case 'csv':
            return 'csv';
        case 'png':
            return 'png';
        case 'jpg':
            return 'jpg';
        case 'jpeg':
            return 'jpeg';
        case 'bmp':
            return 'bmp';
        case 'log':
            return 'log';
        case 'flv':
        case 'mp4':
        case 'ogv':
        case 'webm':
            return 'video';
        }
    }

    return 'def';
};

//CQ:CQ00283052
Utils.getMimeTypes = function (fileName) {
    'use strict';
    if (!fileName) {
        return null;
    }

    var fileExt = fileName.split('.').pop();
    if (fileExt) {
        switch (fileExt.toLowerCase()) {
        case 'xlsx':
            return 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        case 'xltx':
            return 'application/vnd.openxmlformats-officedocument.spreadsheetml.template';
        case 'potx':
            return 'application/vnd.openxmlformats-officedocument.presentationml.template';
        case 'ppsx':
            return 'application/vnd.openxmlformats-officedocument.presentationml.slideshow';
        case 'pptx':
            return 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
        case 'sldx':
            return 'application/vnd.openxmlformats-officedocument.presentationml.slide';
        case 'docx':
            return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        case 'dotx':
            return 'application/vnd.openxmlformats-officedocument.wordprocessingml.template';
        case 'xlam':
            return 'application/vnd.ms-excel.addin.macroEnabled.12';
        case 'xlsb':
            return 'application/vnd.ms-excel.sheet.binary.macroEnabled.12';
        }
    }

    return 'text/plain';
};

Utils.stripUrl = function (url) {
    'use strict';
    return (url && url.lastIndexOf('/') === (url.length - 1))  ? url.slice(0, -1) : url;
};

Utils.isChromeAppMode = function () {
    'use strict';
    return !!(window.chrome && window.chrome.runtime && window.chrome.runtime.id);
};

Utils.textToHtmlEscaped = function (str, handleTextNewLines) { // Method to escape text as html but keep line changes
    'use strict';
    var newLinesReplace = handleTextNewLines ? '&nbsp;': '<br>'; // In selector we want spaces instead of new \n or \r
    return str
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\r?\n/g, newLinesReplace);
};

Utils.linkifyContent = function (content, contentType) {
    'use strict';
    switch (contentType) {
    case 'RICH':
        return linkifyHtml(content); // When content is html, parsing is done node-wise, and every text nodes is parsed for links
    case 'PLAIN':
        return linkifyText(content); // When content is plain text, html tags are escaped and content is linkified as text
    }
    return content;

    function linkifyHtml(content) {
        var inputDOM = document.createElement('div');
        var linkifiedDOM = document.createElement('div');
        inputDOM.innerHTML = content;
        return linkifyNode(inputDOM, linkifiedDOM).innerHTML.replace(/&nbsp;/gi, ' ');
    }

    function linkifyText(text) {
        var LT = String.fromCharCode(17); // Temporary mapping using non-printable ascii code x11 (DEC 17) for char "<" replacements
        var GT = String.fromCharCode(18); // Temporary mapping using non-printable ascii code x12 (DEC 18) for char ">" replacements
        var QUOT = String.fromCharCode(19); // Temporary mapping using non-printable ascii code x13 (DEC 19) for char "'" replacements

        // This temporary replacement using the non-printable chars is done in order to
        // exclude the chars used to compose an href tag (<,>,') from the html escape process when in plain text mode.
        return Utils.textToHtmlEscaped(text
            .replace(Utils.URL_PATTERN, LT + 'a href=' + QUOT + '$&' + QUOT + ' onclick=Utils.openURLtab(' + QUOT + '$&' + QUOT + ');' +  ' target=' + QUOT + '_blank' + QUOT + GT + '$&' + LT + '/a' + GT)
            .replace(Utils.PSEUDO_URL_PATTERN, '$1' + LT + 'a href=' + QUOT + 'http://$2' + QUOT + 'onclick=Utils.openURLtab(' + QUOT + 'http://$2' + QUOT + ');' + ' target=' + QUOT + '_blank' + QUOT + GT + '$2' + LT + '/a' + GT)
            .replace(Utils.EMAIL_ADDRESS_PATTERN, LT + 'a href=' + QUOT + 'mailto:$&' + QUOT + ' target=' + QUOT + '_blank' + QUOT + GT + '$&' + LT + '/a' + GT))
            .replace(/\x11/gi, '<') // Linkify was done, replace them back
            .replace(/\x12/gi, '>')
            .replace(/\x13/gi, '\'');
    }

    function linkifyNode(startNode, linkifiedDOM) { // Node traversing method in order to find text nodes and linkify them
        var i, ii, currentNode;

        for (i = 0, ii = startNode.childNodes.length; i < ii; i++) {
            currentNode = startNode.childNodes[i];
            switch (currentNode.nodeType) {
            case 1:  // ELEMENT_NODE
                linkifyNode(currentNode, linkifiedDOM);
                break;
            case 3:  // TEXT_NODE
                linkifiedDOM.innerHTML = linkifyText(currentNode.textContent);
                i += linkifiedDOM.childNodes.length - 1;
                while (linkifiedDOM.childNodes.length) {
                    startNode.insertBefore(linkifiedDOM.childNodes[0], currentNode);
                }
                startNode.removeChild(currentNode);
            }
        }
        return startNode;
    }
};


Utils.openURLtab = function (url) {
    'use strict';
    if (!url) {
        return;
    }
    window.event.preventDefault();
    var a = document.createElement('a');
    a.href = url;
    var evt = document.createEvent('MouseEvents');//Simulate ctrl+click event
    evt.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, !Utils.isMacOs, false, false, Utils.isMacOs, 0, null); // When windows set ctrlKeyArg to true and metaKeyArg false, if MacOs vice versa, in MacOS ctrl key is cmd key = meta
    a.dispatchEvent(evt);
    window.event.cancelBubble = true;
    evt.stopPropagation();
};

Utils.invalidFileTypes = ['ade', 'adp', 'app', 'asp', 'bas', 'bat', 'cer', 'chm', 'cmd', 'cnt', 'com', 'cpl', 'crt', 'csh', 'der', 'exe', 'fxp', 'gadget', 'hlp', 'hpj', 'hta', 'inf', 'ins', 'isp', 'its', 'js', 'jse', 'ksh', 'lnk', 'mad', 'maf', 'mag', 'mam', 'maq', 'mar', 'mas', 'mat', 'mau', 'mav', 'maw', 'mda', 'mdb', 'mde', 'mdt', 'mdw', 'mdz', 'msc', 'msh', 'msh1', 'msh1xml', 'msh2', 'msh2xml', 'mshxml', 'msi', 'msp', 'mst', 'ops', 'osd', 'pcd', 'pif', 'plg', 'prf', 'prg', 'ps1', 'ps1xml', 'ps2', 'ps2xml', 'psc1', 'psc2', 'pst', 'reg', 'scf', 'scr', 'sct', 'shs', 'tmp', 'url', 'vb', 'vbe', 'vbp', 'vbs', 'vsmacros', 'vsw', 'ws', 'wsc', 'wsf', 'wsh', 'xnk'];

/**
 * Returns true if child element is either equal the ancestor element or a nested descendant of the ancestor element.
 */
Utils.isDescendentOrEqual = function (child, ancestor) {
    'use strict';
    if (child === ancestor) {
        return true;
    }
    var _parent = child;
    while (_parent) {
        _parent = _parent.parentElement;
        if (_parent === ancestor) {
            return true;
        }
    }
    return false;
};

Utils.isSupportedImage = function (mimeType) {
    'use strict';
    var regExp = /^image\/(jpeg|gif|bmp|png)$/i;
    return regExp.test(mimeType); // Accept only image/jpeg, image/gif, image/bmp and image/png MIME types
};

/**
 * Returns a copy of the source object
 */
Utils.shallowCopy = function (src) {
    'use strict';
    if (!src || typeof(src) !== 'object') {
        return src;
    }

    var flattenSrc = Utils.flattenObj(src);
    var obj = {};
    for (var key in flattenSrc) {
        if (flattenSrc.hasOwnProperty(key)) {
            obj[key] = flattenSrc[key];
        }
    }
    return obj;
};

/**
 * Returns the normalized locale string ('en-US' to 'EN_US' or 'de-DE' to 'DE_DE' or 'DE_DE' to 'DE_DE') or
 * undefined if the parameter is not valid
 */
Utils.normalizeLocaleProto = function (locale) {
    'use strict';
    var proto;
    if (locale && locale.length >= 5) {
        proto = locale.substr(0, 2).toUpperCase() + '_' + locale.substr(3, locale.length - 3);
    }
    return proto;
};

/**
 * Returns the normalized locale string ('EN_US' to 'en-US' or 'DE_DE' to 'de-DE' or 'de-DE' to 'de-DE') or
 * undefined if the parameter is not valid
 */
Utils.normalizeLocale = function (proto) {
    'use strict';
    var locale;
    if (proto && proto.length >= 5) {
        locale = proto.substr(0, 2).toLowerCase() + '-' + proto.substr(3, proto.length - 3);
    }
    return locale;
};

/**
 * Calculates local time based on a time zone offset (optional)
 */
Utils.getLocalTime = function (timeZoneOffset) {
    'use strict';
    var currentDate = new Date();
    if (timeZoneOffset === null || timeZoneOffset === undefined) { // 0 value is a possible value as well
        return currentDate.getTime();
    }
    // Include my offset in calc as well
    currentDate.setTime(currentDate.getTime() + (currentDate.getTimezoneOffset() - timeZoneOffset) * 60 * 1000);
    return currentDate.getTime();
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// New APIs for String objects
///////////////////////////////////////////////////////////////////////////////////////////////////

// Remove spaces
String.prototype.removeSpaces = function () {
    'use strict';
    return this.replace(/\s/g, '');
};

// Trim String
String.prototype.trim = function () {
    'use strict';
    return this.replace(/^\s+|\s+$/g, '');
};

// To Camel Case
String.prototype.toCamel = function () {
    'use strict';
    return this.replace(/(\-[a-z])/g, function ($1) {
        return $1.toUpperCase().replace('-', '');
    });
};

// To Dashed from Camel Case
String.prototype.toDash = function () {
    'use strict';
    return this.replace(/([A-Z])/g, function ($1) {
        return '-' + $1.toLowerCase();
    });
};

// To Underscore from Camel Case
String.prototype.toUnderscore = function () {
    'use strict';
    return this.replace(/([A-Z])/g, function ($1) {
        return '_' + $1.toLowerCase();
    });
};

// StartsWith
String.prototype.startsWith = function (str) {
    'use strict';
    if (!str || this.length < str.length) {
        return false;
    }
    return this.substring(0, str.length) === str;
};

// EndsWith
String.prototype.endsWith = function (str, ignoreCase) {
    'use strict';
    if (!str || this.length < str.length) {
        return false;
    }
    if (ignoreCase) {
        return (this.toLowerCase()).substring(this.length - str.length) === str.toLowerCase();
    }
    return this.substring(this.length - str.length) === str;
};

// RemoveTrailingSubstring
String.prototype.removeTrailingSubstring = function (str, ignoreCase) {
    'use strict';
    var _this = this;
    if (_this.endsWith(str, ignoreCase)) {
        _this = (_this.substring(0, _this.length - str.length)).removeTrailingSubstring(str, ignoreCase);
    }
    return _this;
};

/**
 *  Checks if a given timestamp is older than a given day period
 */
Utils.isOlderThan = function (timeToCheck, daysOlder) {
    'use strict';
    if (!(timeToCheck && daysOlder)) {
        return null;
    }

    var dateToCheck = new Date(timeToCheck);
    var currentDate = new Date();
    return ((currentDate - dateToCheck) > 86400000);//one day in millis
};

Utils.bytesToSize = function (bytes) {
    'use strict';
    if (!bytes) { return '0 Bytes'; }
    var k = 1024;
    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);
    return Number((bytes / Math.pow(k, i)).toPrecision(3)) + ' ' + sizes[i];
};

Utils.isMacOs = window.navigator && window.navigator.userAgent ? window.navigator.userAgent.indexOf('Mac') !== -1 : false; // Check if Mac OS, default false

Utils.daysBetween = function (firstDate, secondDate) {
    'use strict';
    // ensure that both objects are dates, and that the first date precedes the second
    if (firstDate instanceof Date && secondDate instanceof Date) {
        var MS_ONE_DAY = 1000 * 60 * 60 * 24;
        return Math.ceil(Math.abs(secondDate.getTime() - firstDate.getTime()) / MS_ONE_DAY);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// New APIs for Array objects
///////////////////////////////////////////////////////////////////////////////////////////////////

// isEmpty
if (!Array.prototype.isEmpty) {
    Array.prototype.isEmpty = function () {
        'use strict';
        return this.length === 0;
    };
}

// last element
if (!Array.prototype.last) {
    Array.prototype.last = function () {
        'use strict';
        if (this.length > 0) {
            return this[this.length - 1];
        }
    };
}

// Optimized array shuffler based on http://jsperf.com/array-shuffle-comparator and
// http://jsperf.com/shuffle-optimization-00129393
Array.prototype.shuffle = function () {
    'use strict';
    var l = this.length + 1;
    while (l--) {
        var r = Math.floor(Math.random() * l);
        var o = this[r];
        this[r] = this[0];
        this[0] = o;
    }
    return this;
};

Array.prototype.randomCopy = function (numElems) {
    'use strict';
    var copy = this.slice(0);
    copy.shuffle();
    return copy.splice(0, numElems);
};

// move one element from old position to new position
Array.prototype.move = function (oldPos, newPos) {
    'use strict';
    if (newPos >= this.length) {
        var k = newPos - this.length;
        while ((k--) + 1) {
            this.push(undefined);
        }
    }
    this.splice(newPos, 0, this.splice(oldPos, 1)[0]);
};

// remove a single object from an array
Array.prototype.remove = function (obj) {
    'use strict';
    if (typeof obj !== 'undefined' && obj) {
        var index = this.indexOf(obj);
        if (index > -1) {
            this.splice(index, 1);
        }
    }
};

//Check if array object contains a value
Array.prototype.contains = function (value) {
    'use strict';
    return this.indexOf(value) > -1;
};

// Returns the first array object that satisfied the given predicate
Array.prototype.findFirst = function (cb) {
    'use strict';
    if (typeof cb !== 'function') {
        return undefined;
    }

    for (var i = 0; i < this.length; i++) {
        if (cb(this[i])) {
            return this[i];
        }
    }

    return undefined;
};

// Finds and removes the first array object that satisfied the given predicate
Array.prototype.findAndRemove = function (cb) {
    'use strict';
    if (typeof cb !== 'function') {
        return undefined;
    }

    for (var i = 0; i < this.length; i++) {
        if (cb(this[i])) {
            return this.splice(i, 1);
        }
    }

    return undefined;
};

// Thanks to the BinarySearch from http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/
// This function finds the right position and inserts the searchElement.
// It works even when the array is empty.
Array.prototype.binaryInsert = function (searchElement, compareFunction) {
    'use strict';

    if (!compareFunction || typeof(compareFunction) !== 'function') {
        // no compare function supplied
        return false;
    }

    var minIndex = 0;
    var maxIndex = this.length - 1;
    var currentIndex;
    var currentElement;
    var found = false;

    while (minIndex <= maxIndex) {
        currentIndex = Math.floor((minIndex + maxIndex) / 2);
        currentElement = this[currentIndex];

        if (compareFunction(currentElement, searchElement) < 0) {
            minIndex = currentIndex + 1;
        }
        else if (compareFunction(currentElement, searchElement) > 0) {
            maxIndex = currentIndex - 1;
        }
        else {
            found = true;
            break;
        }
    }

    var indexToInsert = found ? currentIndex + 1 : minIndex;
    if (indexToInsert >= 0) {
        this.splice(indexToInsert, 0, searchElement);
        return true;
    }

    return false;
};

// Empties an array. The most performant way to achieve this.
if (!Array.prototype.hasOwnProperty('empty')) {
    Array.prototype.empty = function () {
        'use strict';
        while (this.length > 0) {
            this.pop();
        }
    };
}

// Resets the curent array and copies all elements from source
// array to the current array.
if (!Array.prototype.copy) {
    Array.prototype.copy = function (srcArray) {
        'use strict';
        this.empty();
        this.push.apply(this, srcArray);
    };
}

// Array difference.
if (!Array.prototype.hasOwnProperty('diff')) {
    Array.prototype.diff = function (someArray) {
        'use strict';
        return this.filter(function (i) { return !someArray.contains(i); });
    };
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// New static API for RegExp type
///////////////////////////////////////////////////////////////////////////////////////////////////
RegExp.escape = function (str) {
    'use strict';
    if (!str) {
        return '';
    }
    var regex = str.replace(/[.*+?|()\[\]{}\\$^]/g, '\\$&');
    return regex;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// New APIs for Date objects
///////////////////////////////////////////////////////////////////////////////////////////////////
Date.prototype.moveToEndOfDay = function () {
    'use strict';
    return this.set({hour: 23, minute: 59, second: 59});
};
Date.prototype.moveToFirstDayOfYear = function () {
    'use strict';
    return this.set({day: 1, month: 0});
};
Date.prototype.moveToLastDayOfYear = function () {
    'use strict';
    return this.set({month: 11}).moveToLastDayOfMonth();
};
